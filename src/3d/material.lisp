;;; -*- Mode:Lisp; Syntax:ANSI-Common-Lisp; Coding:utf-8 -*-

(in-package #:uid)

;;the goal is simple: dont wanna specify a 3d model and a texture and
;;some tweaked uv's (st's), just wanna specify an object and a
;;material.  Steps: * 3d texture algorithms * mapping to 2d textures
;;(requires texture coordinate generation) * texturing in draw routine
;;and btw we ignore target here completely

(defproto =gl-texture= (=texture=)
  ((target :texture-2d)
   )
  (:documentation "a texture that is not loaded via ilut, but filled directly into the corresponding buffer"))

(defun smartpixels->dumbpixels (vec)
  "Coverts an array of pixels to the corresponding gl type, also
returns that and the format. Pixels are expected as floats from 0.0 to
1.0 and will be converted as needed. values: format type data"
  (assert (> (length vec) 0))
  (let ((num-of-channels (length (svref vec 0)))
	(type :unsigned-byte))
    (ecase num-of-channels
      (1 ;;just luminance
       (values :luminance type (loop
				  with result-vec = (make-array (length vec))
				  for pixel across vec
				  for i from 0 by 1 do
				  (setf (svref result-vec i) (truncate (* (svref pixel 0) 255)))
				  finally (return result-vec))))
      (2 ;;luminance and alpha
       (error "TBD"))
      (3 ;;rgb
       (error "TBD"))
      (4 ;; rgba
       (error "TBD")))))

(defmessage get-pixel-vector (tex)
  (:documentation "mandatory, must return a valid(tm) vector of pixels, see smartpixels->dumbpixels for what that could be"))

;;create a buffer and fill it with something here, then give it to gl memory
;;TODO: include some memory use estimation and tracking
(defreply load-resource ((tex =gl-texture=))
  "reserves a tex id and calls get-texture-data"
  (with-properties (tex-id width height) tex
    (setf tex-id (gl:gen-texture))
    (gl:bind-texture :texture-2d tex-id)
    ;;default: linear filtering
    (gl:tex-parameter :texture-2d :texture-mag-filter :linear)
    (gl:tex-parameter :texture-2d :texture-min-filter :linear)
      (multiple-value-bind (format type data)
	  (smartpixels->dumbpixels (get-pixel-vector tex))
	(gl:tex-image-2d :texture-2d 0 format width height 0 format type data))    
    (gl:bind-texture :texture-2d 0)))

(defproto =procedural-texture= =gl-texture=
  ((seed 1)
   buffer ;;this is used to debug shit
   )
  (:documentation "a texture that is generated by an algorithm"))

(defreply get-pixel-vector ((proc-tex =procedural-texture=))
  (with-properties (width height buffer) proc-tex
    (loop for y from 0 below width append
	 (loop for x from 0 below height
	    for pixel = (generate-pixel proc-tex x y) collect
	    (if (vectorp pixel)
		pixel
		(vector pixel)))
	 into lines
	 finally (return (setf buffer (coerce lines 'vector))))))

;;this is just grayscale right now, need an abstraction for colors, perhaps
;;TODO: implement channel based materials somehow (RGBA)
(defproto =perlin-noise-texture= =procedural-texture=
  ((fmin 0.1)
   func)
  )

(defreply shared-init ((tex =perlin-noise-texture=) &key)
  (with-properties (func seed) tex
    (setf func (make-perlin-noise seed)))
  (call-next-reply))

(defreply generate-pixel ((tex =perlin-noise-texture=) x y)
  "returns width x height pixel values (line-wise, so to speak)"
  (with-properties (func width height fmin) tex
    ;;proper rescaling to [0 1]
     (* 0.5
       (1+ (funcall func (vector (* fmin (/ x width)) (* fmin (/ y height))))))))