;;; -*- Mode:Lisp; Syntax:ANSI-Common-Lisp; Coding:utf-8 -*-

(in-package #:uid)

;;the goal is simple: dont wanna specify a 3d model and a texture and
;;some tweaked uv's (st's), just wanna specify an object and a
;;material.  Steps: * 3d texture algorithms * mapping to 2d textures
;;(requires texture coordinate generation) * texturing in draw routine
;;and btw we ignore target here completely

(defproto =gl-texture= (=texture=)
  ((target nil)
   )
  (:documentation "a texture that is not loaded via ilut, but filled directly into the corresponding buffer"))

(defun smartpixels->dumbpixels (vec)
   "Coverts an array of pixels to the corresponding gl type, also
returns that and the format. Pixels are expected as floats from 0.0 to
1.0 and will be converted as needed. values: format type data"
  (assert (> (length vec) 0))
  (let ((num-of-channels (length (svref vec 0)))
	(type :unsigned-byte))
    (ecase num-of-channels
      (1 ;;just luminance
       (values :luminance type (loop for pixel across vec collect (truncate (* pixel 255)))))
      (2 ;;luminance and alpha
       (error "TBD"))
      (3 ;;rgb
       (error "TBD"))
      (4 ;; rgba
       (error "TBD")))))

;;create a buffer and fill it with something here, then give it to gl memory
;;TODO: include some memory use estimation and tracking
(defreply load-resource ((tex =gl-texture=))
  "reserves a tex id and calls load-texture"
  (with-properties (tex-id width height) tex
    (setf tex-id (gl:gen-texture))
    (gl:bind-texture :texture-2d tex-id)
    ;;default: linear filtering
    (gl:tex-parameter :texture-2d :texture-mag-filter :linear)
    (gl:tex-parameter :texture-2d :texture-min-filter :linear)
    (let ((pixel-vector (loop for y from 0 below width append
			     (loop for x from 0 below height collect
				  (generate-pixel tex x y))
			   into lines
			   finally (return (coerce lines 'vector)))))
      (multiple-value-bind (format type data)
	  (smartpixels->dumbpixels pixel-vector)
	(gl:tex-image-2d :texture-2d 0 format width height 0 format type data)))
    (gl:bind-texture :texture-2d 0)))

(defproto =procedural-texture= =gl-texture=
  ((seed 1))
  (:documentation "a texture that is generated by an algorithm"))


;;this is just grayscale right now, need an abstraction for colors, perhaps
;;TODO: implement channel based materials somehow (RGBA)
(defproto =perlin-noise-texture= =procedural-texture=
  ((fmin 0.1)
   func)
  )

(defreply shared-init ((tex =perlin-noise-texture=) &key)
  (with-properties (func seed) tex
    (setf func (make-perlin-noise seed)))
  (call-next-reply))

(defreply generate-pixel ((tex =perlin-noise-texture=) x y)
  "returns width x height pixel values (line-wise, so to speak"
  (with-properties (func width height) tex
    ;;proper rescaling to [0 1]
     (* 0.5
       (1+ (funcall func (vector (/ x width) (/ y height)))))))